/**
 * UI-NEW-004: Node Content Editing Wrapper Component
 * UI-NEW-005: Node Forking Support (Non-destructive editing)
 *
 * A wrapper component that adds content editing interaction to existing node components.
 * Use this to wrap UserNode and AINode when using them in the canvas.
 *
 * The update/fork callback is provided via NodeEditingContext instead of props,
 * allowing nodeTypes to remain stable across renders.
 *
 * NOTE: User nodes no longer support inline editing. Branching is now done via
 * the (+) button shown on hover.
 */

"use client";

import { memo } from "react";
import { useNodeEditingContext } from "@/contexts/NodeEditingContext";
import { AINode as BaseAINode } from "./AINode";
import type { AINodeProps, MindFlowNode, UserNodeProps } from "./types";
import { UserNode as BaseUserNode } from "./UserNode";

// ============================================================================
// Type Definitions
// ============================================================================

export interface EditableNodeProps {
	/** The React Flow node data */
	node: MindFlowNode;
	/** Whether the node is currently hovered (detected by React Flow) */
	isHovered?: boolean;
}

// ============================================================================
// Editable Wrapper Components
// ============================================================================

/**
 * UserNode wrapper component.
 *
 * User nodes no longer support inline editing. Branching is done via the (+)
 * button shown on hover.
 *
 * @example
 * ```tsx
 * <EditableUserNode
 *   node={node}
 *   isHovered={isHovered}
 * />
 * ```
 */
export const EditableUserNode = memo<
	EditableNodeProps & Omit<UserNodeProps, "data" | "selected">
>(function EditableUserNode({ node, isHovered = false, ...props }) {
	// Get onCreateChild and hover state from context
	const { onCreateChild, hoveredNodeId: contextHoveredNodeId } =
		useNodeEditingContext();

	// Use context hover state if available, otherwise fall back to prop
	const isActuallyHovered = contextHoveredNodeId === node.id || isHovered;

	return (
		<BaseUserNode
			data={node.data}
			selected={node.selected}
			isHovered={isActuallyHovered}
			onCreateChild={() => onCreateChild(node.data.id)}
			{...props}
		/>
	);
});

/**
 * AINode wrapper component.
 *
 * AI nodes don't support direct editing (they're generated by the AI model).
 * This wrapper provides the node with proper props and handles regeneration interactions.
 *
 * @example
 * ```tsx
 * <EditableAINode
 *   node={node}
 *   isHovered={isHovered}
 * />
 * ```
 */
export const EditableAINode = memo<
	EditableNodeProps & Omit<AINodeProps, "data" | "selected">
>(function EditableAINode({ node, isHovered = false, ...props }) {
	// Get onCreateChild and hover state from context
	const { onCreateChild, hoveredNodeId: contextHoveredNodeId } =
		useNodeEditingContext();

	// Use context hover state if available, otherwise fall back to prop
	const isActuallyHovered = contextHoveredNodeId === node.id || isHovered;

	// AI nodes don't support editing, so we just pass through the data
	return (
		<BaseAINode
			data={node.data}
			selected={node.selected}
			isHovered={isActuallyHovered}
			onCreateChild={() => onCreateChild(node.data.id)}
			{...props}
		/>
	);
});

// ============================================================================
// Node Factory Function
// ============================================================================

/**
 * Creates an editable node component with content editing support.
 *
 * This factory function returns the appropriate node component based on the role:
 * - USER nodes: returns EditableUserNode (with editing support)
 * - ASSISTANT nodes: returns EditableAINode (AI-generated, no editing)
 * - SYSTEM nodes: returns EditableUserNode (with editing support, for now)
 *
 * The update callback is provided via NodeEditingContext, allowing the
 * nodeTypes object to remain stable across renders.
 *
 * @returns A function that renders the node with appropriate component
 *
 * @example
 * ```tsx
 * import { NodeEditingProvider } from "@/contexts/NodeEditingContext";
 *
 * // Define stable nodeTypes (can be outside component or memoized)
 * const nodeTypes = {
 *   user: createEditableNode(),
 *   assistant: createEditableNode(),
 *   system: createEditableNode(),
 * };
 *
 * // Wrap canvas with provider
 * <NodeEditingProvider onUpdateContent={handleUpdate}>
 *   <InfiniteCanvas nodeTypes={nodeTypes} ... />
 * </NodeEditingProvider>
 * ```
 */
export function createEditableNode() {
	return function EditableNode(
		// biome-ignore lint/suspicious/noExplicitAny: ReactFlow node props are complex and dynamically typed
		props: any,
	) {
		// Props from React Flow contain data, selected, etc. directly
		const node: MindFlowNode = {
			id: props.data.id,
			type: props.type,
			position: props.position,
			data: props.data,
			selected: props.selected,
		};

		const role = node.data.role || "USER";

		// Render the appropriate component based on role
		if (role === "ASSISTANT") {
			return <EditableAINode node={node} isHovered={props.isHovered} />;
		}

		// Default to UserNode for USER and SYSTEM roles
		return <EditableUserNode node={node} isHovered={props.isHovered} />;
	};
}
