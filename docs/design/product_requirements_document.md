# 结构化思维流聊天机器人 (MindFlow) - 产品定义文档 (PRD)

## 1. 产品背景与问题陈述 (Context & Problem)

### 1.1 现状
目前的主流 AI 产品（ChatGPT, Claude）仍沿用传统的 **IM（即时通讯）** 隐喻。这种线性的“流”结构虽然适合简单的问答，但在面对**复杂项目**（如长篇写作、系统架构、复杂的逻辑推演）时，会导致严重的信息碎片化和上下文迷失。

### 1.2 核心冲突
*   **思维的非线性 vs. 交互的线性**：人类在解决复杂问题时，思维往往是发散的、网状的（Graph），而聊天框强迫我们将思维压缩成一条线（Stream）。
*   **项目的持久性 vs. 会话的临时性**：复杂的任务需要长期的、结构化的组织（Project），而“聊天会话”往往是随意的、用完即弃的。

## 2. 产品愿景 (Vision)
**MindFlow** 是一款 **AI 原生的可视化思维空间 (AI-Native Visual Workspace)**。
我们摒弃传统的“聊天机器人”形态，打造一个以**无限画布 (Infinite Canvas)** 为核心的交互界面。在这里，**图 (Graph)** 不再是辅助的导航，而是**内容本身**。用户在一个持久化的“项目”中，与 AI 共同编织思维网络。

## 3. 产品定位 (Positioning)
*   **形态**：Node-based AI Editor (类似 Obsidian Canvas 或 Miro，但每个节点都是活的 AI)。
*   **组织**：以 **“项目 (Project)”** 为单位，而非“会话 (Chat)”。
*   **价值**：将隐性的思维过程显性化，支持结构化的创造与决策。

## 4. 核心功能与交互设计 (Core Features & UX)

### 4.1 界面布局：画布优先 (Canvas First)
*   **主视图 (Main View)**：全屏的无限画布。
    *   用户直接在画布上创建、拖拽、连接节点。
    *   整个思维结构一目了然。
*   **辅助视图 (Auxiliary Panel)**：右侧悬浮面板 (Inspector/Chat Panel)。
    *   当选中某个节点时，右侧展开该节点的详细内容或线性对话历史。
    *   线性对话是辅助的，用于在局部进行深入的文本交互。

### 4.2 组织形式：项目制 (Project-based)
*   **Project = Graph**: 一个项目对应唯一的一个无限画布。图就是项目本身，不再有中间的“图列表”层级。
*   **Project Dashboard**: 首页展示项目卡片列表。点击卡片直接进入该项目的全屏画布。
*   **持久化**: 项目内的所有节点、连线和布局状态都会自动保存。用户下次进入时，画布状态与离开时完全一致。

### 4.3 核心交互：节点生长 (Node Growth)
*   **Prompt as Node**: 用户在画布空白处双击 -> 创建一个 User Node (输入 Prompt)。
*   **Generation as Node**: AI 的回复自动生成为一个连接的 AI Node。
*   **Branching**: 用户可以从任意 AI Node 拖出连线，创建新的 User Node（提问），从而形成分支。
*   **Exploration**: 用户可以同时发展多个分支，并在空间上并列展示，进行直观对比。

### 4.4 上下文感知 (Context-Awareness)
*   **Visual Context**: 连线即上下文。AI 在回答某个节点时，自动读取从 Root 到该节点路径上的所有信息。
*   **Selective Context**: (高级功能) 用户可以手动连线，将画布上不相关的节点连接起来，强制让 AI 关注这些信息（RAG 的可视化配置）。

## 5. 目标用户场景 (User Scenarios)

| 用户群体 | 典型场景 | 价值主张 |
| :--- | :--- | :--- |
| **架构师/开发者** | 系统设计 | 在画布上画出微服务架构，针对每个服务节点让 AI 生成代码或配置，通过空间位置组织复杂的系统关系。 |
| **作家/编剧** | 故事板创作 | 创建“核心冲突”节点，分叉出三个不同的“结局”分支，在画布上直观对比剧情走向。 |
| **研究员** | 知识图谱构建 | 将不同的论文摘要作为节点放入画布，让 AI 寻找它们之间的联系并生成总结节点。 |

## 6. 下一步计划 (Next Steps)
*   设计侧边栏 Tree View 的原型草图。
*   定义数据结构（Node, Edge, Tree）。
*   验证“上下文高亮”交互的可行性。
